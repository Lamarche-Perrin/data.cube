[
["index.html", "Introduction Installation Authors and License", " Introduction data.cube is an R package for the exploration of multidimensional datasets and for the detection of statistical outliers within. It is mainly a tool for data exploration, allowing to have a first glance at it and to formulate research hypotheses to be later tested. The package defines a new data structure called data.cube that can be fed with a classical data.frame encoding a list of numeric observations described according to several categorical dimensions. For example, in the case of Twitter data, it can be the number of tweets (numeric observation) that have been published by a given user (first dimension) about a given topic (second dimension) at a given date (third dimension). The input data.frame hence takes the form of a list of quadruplets (user, topic, date, number of tweets). Statistical outliers can then be identified among the observations by first selecting some dimensions of interest, that is by subsetting or by aggregating the input dimensions. If needed, observations can also be normalised according to the marginal values along the selected dimensions, thus comparing the observed value to an expected value obtained by the uniform redistribution of the selected marginal values. Different statistical tests can then be chosen to measure the deviation between the observed and the expected values. The package finally allows to retrieve a list of positive outliers, that is observations that are significantly higher than expected. Installation The library is available on CRAN: install.packages (&#39;data.cube&#39;) Its source code is available on GitHub: https://github.com/Lamarche-Perrin/data.cube Authors and License This library has been developed by researchers of the Complex Networks team, within the Laboratoire d’informatique de Paris 6, for the ODYCCEUS project, founded by the European Commission FETPROACT 2016-2017 program under grant 732942. Copyright © 2017-2019 Robin Lamarche-Perrin (Robin.Lamarche-Perrin@lip6.fr) data.cube is free software: you can redistribute it and/or modify it under the terms of the GNU General Public License as published by the Free Software Foundation, either version 3 of the License, or (at your option) any later version. It is distributed in the hope that it will be useful, but WITHOUT ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the GN General Public License for more details. You should have received a copy of the GNU General Public License along with this program. If not, see http://www.gnu.org/licenses/. "],
["getting-started.html", "1 Getting Started 1.1 Downloading the dataset 1.2 Loading the library 1.3 Building the cube with as.data.cube 1.4 What’s in the cube with summary 1.5 Back to frame with as.data.frame", " 1 Getting Started This tutorial assumes that you are familiar with the most known R packages of the tidyverse, in particular tibble operations provided by dplyr and the forward-pipe operator %&gt;% provided by magrittr. 1.1 Downloading the dataset This tutorial presents a use case of the data.cube library on a quite simple dataset (downloadable here) referencing the citations of country names in press articles. This dataset has been extracted from the corpus of articles gathered by the ANR GEOMEDIA Project. First, import the main file of this dataset as a data.frame (actually, as a tibble): library (readr) df &lt;- read_csv (&#39;data/articles.csv&#39;) ## Parsed with column specification: ## cols( ## id_media = col_character(), ## week = col_date(format = &quot;&quot;), ## id_country = col_character(), ## article_nb = col_double() ## ) head (df) ## # A tibble: 6 x 4 ## id_media week id_country article_nb ## &lt;chr&gt; &lt;date&gt; &lt;chr&gt; &lt;dbl&gt; ## 1 en_NZL_nzhera_int 2015-06-01 SVK 0.333 ## 2 en_NZL_nzhera_int 2015-03-09 VEN 10.5 ## 3 es_VEN_univer_int 2014-05-19 LBY 9 ## 4 en_MYS_starmy_int 2014-10-13 PSE 9 ## 5 en_NZL_nzhera_int 2014-06-09 GTM 1.5 ## 6 en_MYS_starmy_int 2015-06-22 ARG 3 First column id_media contains standardised identifiers of selected newspapers. Second column week contains publication dates at the week level (date of the first day of the week at the YYYY-MM-DD format). Third column id_country contains standardised identifiers of cited countries (ISO 3166-1 alpha-3). Last column article_nb gives the corresponding number of articles, that is the number of articles published by id_media during week and citing id_country. For example, the third line of the dataset above indicates that the Venezuelan newspaper El Universal (es_VEN_univer_int) as published 9 articles talking about Libya (LBY) during the week starting on the 19th of May, 2014 (2014-05-19). Note that the indicated number of articles is not necessarily an integer value (see for example the first line) as an article simultaneously citing n countries is weighted by 1/n and then distributed among n lines. 1.2 Loading the library First, load the library: library (data.cube) 1.3 Building the cube with as.data.cube Function as.data.cube transforms a classical data.frame (or tibble) object into a data.cube, that is the data structure that will then be used by the library. One should specify which columns correspond to the cube’s dimensions (in our case, the first three) and which columns correspond to the observed variables (in our case, the last one). Note that one might also rename these dimensions and variables when transforming the data.frame into a data.cube. geomedia &lt;- df %&gt;% as.data.cube ( dim.names = list (media = id_media, week, country = id_country), var.names = list (articles = article_nb) ) ## Warning in as.data.cube_.data.frame(., str.dim.names, str.var.names): ## Observations are assumed to be unique. Check for potential duplicates in ## the input data.frame if unsure. 1.4 What’s in the cube with summary Function summary then prints a short summary of the data contained in the resulting structure. geomedia %&gt;% summary () ## data.cube of 3 dimensions and 1 variable ## ## -&gt; Dimension media ## - Element number: 36 ## - Class (type): character (character) ## - Element names: en_NZL_nzhera_int, es_VEN_univer_int, en_MYS_starmy_int, ... ## ## -&gt; Dimension week ## - Element number: 79 ## - Class (type): Date (double) ## - Element names: 2015-06-01, 2015-03-09, 2014-05-19, 2014-10-13, 2014-06-09, ... ## ## -&gt; Dimension country ## - Element number: 205 ## - Class (type): character (character) ## - Element names: SVK, VEN, LBY, PSE, GTM, ARG, ARM, AFG, NRU, MEX, IRN, ... ## ## -&gt; Variable articles ## - Dimensions: media x week x country ## - Class (type): numeric (double) ## - NA value: num 0 1.5 Back to frame with as.data.frame Function as.data.frame transforms a data.cube object back into a data.frame object (actually, a tibble). geomedia %&gt;% as.data.frame () ## # A tibble: 95,674 x 4 ## media week country articles ## &lt;chr&gt; &lt;date&gt; &lt;chr&gt; &lt;dbl&gt; ## 1 en_NZL_nzhera_int 2015-06-01 SVK 0.333 ## 2 en_NZL_nzhera_int 2015-03-09 VEN 10.5 ## 3 es_VEN_univer_int 2014-05-19 LBY 9 ## 4 en_MYS_starmy_int 2014-10-13 PSE 9 ## 5 en_NZL_nzhera_int 2014-06-09 GTM 1.5 ## 6 en_MYS_starmy_int 2015-06-22 ARG 3 ## 7 en_USA_wapost_int 2015-01-05 ARM 0.5 ## 8 es_VEN_univer_int 2014-05-26 AFG 4.5 ## 9 en_GBR_dailyt_int 2015-05-04 NRU 1 ## 10 fr_BEL_derheu_int 2014-06-16 MEX 0.333 ## # … with 95,664 more rows "],
["unidimensional-exploration.html", "2 Unidimensional Exploration 2.1 Selecting one dimension with select.dim 2.2 Arranging elements with arrange.elm 2.3 Plotting variables with plot.var 2.4 Filtering elements with filter.elm and top_n.elm 2.5 Other examples of use", " 2 Unidimensional Exploration In this first section, we focus on the exploration of one dimension of the data.cube. Multidimensional exploration is demonstrated later. 2.1 Selecting one dimension with select.dim One first needs to select the dimension of interest using function select.dim. In this example, we focus on the dataset’s temporal dimension, a.k.a. dimension week. geomedia %&gt;% select.dim (week) %&gt;% as.data.frame () ## # A tibble: 79 x 2 ## week articles ## &lt;date&gt; &lt;dbl&gt; ## 1 2015-06-01 5706. ## 2 2015-03-09 6316. ## 3 2014-05-19 5857. ## 4 2014-10-13 6006. ## 5 2014-06-09 5172. ## 6 2015-06-22 6738. ## 7 2015-01-05 5607. ## 8 2014-05-26 5260. ## 9 2015-05-04 6368. ## 10 2014-06-16 3384. ## # … with 69 more rows The resulting data.cube consists in a unidimensional data structure where variable articles has been aggregated (summed) along dimensions media and country. The resulting data.frame hence gives the total number of published articles corresponding to each element of dimension week. 2.2 Arranging elements with arrange.elm Note that above, observations have no particular order. Function arrange.elm reorders elements of a given dimension according to one (or several) of their variables. For example, the lexicographic order of their name (standard variable created for each dimension when instantiating the data.cube) which happens to also be the chronological order. geomedia %&gt;% select.dim (week) %&gt;% arrange.elm (week, name) %&gt;% as.data.frame () ## # A tibble: 79 x 2 ## week articles ## &lt;date&gt; &lt;dbl&gt; ## 1 2013-12-30 1671. ## 2 2014-01-06 2983. ## 3 2014-01-13 3172. ## 4 2014-01-20 3519. ## 5 2014-01-27 3073. ## 6 2014-02-03 2972. ## 7 2014-02-10 3012. ## 8 2014-02-17 2881. ## 9 2014-02-24 3313. ## 10 2014-03-03 3573. ## # … with 69 more rows 2.3 Plotting variables with plot.var Function plot.var then plots a variable. Note that it returns a ggplot object that can hence be modified using classical tools of the visualisation library. For example, one can use function theme to vertically display x-axis labels. geomedia %&gt;% select.dim (week) %&gt;% arrange.elm (week, name) %&gt;% plot.var (articles) + theme (axis.text.x = element_text (angle = 90, size = 6)) Several plot types are available: bar (above), line (below), and point. geomedia %&gt;% select.dim (week) %&gt;% arrange.elm (week, name) %&gt;% plot.var (articles, type = &quot;line&quot;) + theme (axis.text.x = element_text (angle = 90, size = 6)) 2.4 Filtering elements with filter.elm and top_n.elm Note that some observations in the plot above are surprisingly low. (They actually correspond to technical incidents during data collection.) Function top_n.elm only keeps the elements of a dimension that have the highest (or the lowest) value according to a variable. We here plot the 10 weeks in the data that have the lowest number of published article (note the - in argument n). geomedia %&gt;% select.dim (week) %&gt;% top_n.elm (week, articles, n = -10) %&gt;% arrange.elm (week, articles) %&gt;% plot.var (articles) + theme (axis.text.x = element_text (size = 6)) Function filter.elm only keeps the elements of a dimension that fit with some criteria expressed on variables. We can for example use it to remove such anomalous observations. geomedia %&gt;% select.dim (week) %&gt;% filter.elm (week, articles &gt;= 2500) %&gt;% arrange.elm (week, name) %&gt;% plot.var (articles, type = &quot;line&quot;) + theme (axis.text.x = element_text (angle = 90, size = 6)) 2.5 Other examples of use Here are other examples of use of these simple operations, illustrated on the spatial dimension country. One can plot the number of articles associated with the top 20 countries (arranged in a decreasing order). geomedia %&gt;% select.dim (country) %&gt;% top_n.elm (country, articles, 20) %&gt;% arrange.elm (country, desc (articles)) %&gt;% plot.var (articles) One can filter and arrange countries according to a given subset. G8 &lt;- c (&quot;USA&quot;, &quot;JPN&quot;, &quot;DEU&quot;, &quot;FRA&quot;, &quot;RUS&quot;, &quot;GBR&quot;, &quot;ITA&quot;, &quot;CAN&quot;) geomedia %&gt;% select.dim (country) %&gt;% filter.elm (country, name %in% G8) %&gt;% arrange.elm (country, match (name, G8)) %&gt;% plot.var (articles) "],
["multidimensional-exploration.html", "3 Multidimensional Exploration 3.1 Selecting two dimensions with select.dim 3.2 Plotting bidimensional variables with argument sep.dim.names of plot.var 3.3 Plotting multidimensional variables", " 3 Multidimensional Exploration In this second section, we simultaneously deal with several dimensions. Multidimensional plotting of variables is then possible. 3.1 Selecting two dimensions with select.dim When selecting two dimensions (or more) with function select.dim, one ends up with a multidimensional representation of the corresponding variables. For example, in the code below, one selects dimensions week and country (in other words, dimension media is aggregated). Each observation hence gives the number of articles published during a given week and talking about a given country. geomedia %&gt;% select.dim (week, country) %&gt;% arrange.elm (country, name) %&gt;% arrange.elm (week, name) %&gt;% as.data.frame () ## # A tibble: 11,051 x 3 ## week country articles ## &lt;date&gt; &lt;chr&gt; &lt;dbl&gt; ## 1 2013-12-30 AFG 22 ## 2 2013-12-30 ARG 6 ## 3 2013-12-30 AUS 29.5 ## 4 2013-12-30 BEN 2 ## 5 2013-12-30 BGD 30 ## 6 2013-12-30 BGR 7.67 ## 7 2013-12-30 BHS 2 ## 8 2013-12-30 BLR 0.5 ## 9 2013-12-30 BOL 2.5 ## 10 2013-12-30 BRA 10.5 ## # … with 11,041 more rows 3.2 Plotting bidimensional variables with argument sep.dim.names of plot.var In order to plot variable articles according to the two selected dimensions, one can use argument sep.dim.names of function plot.var to indicate which one of the two dimensions should be used to separate the data. geomedia %&gt;% select.dim (week, country) %&gt;% arrange.elm (week, name) %&gt;% filter.elm (country, name %in% c (&quot;USA&quot;, &quot;FRA&quot;, &quot;DEU&quot;)) %&gt;% plot.var (articles, sep.dim.names = country, type = &quot;line&quot;) + theme (axis.text.x = element_text (angle = 90, size = 6)) In this context, using a point-plot (instead of a line-plot) can be useful to separate a dimension with many elements. (Note that, below, we also use filter.elm on week to only plot data for year 2014.) geomedia %&gt;% select.dim (week, country) %&gt;% filter.elm (week, format (name, &quot;%Y&quot;) == &quot;2014&quot;) %&gt;% arrange.elm (week, name) %&gt;% top_n.elm (country, articles, 20) %&gt;% arrange.elm (country, desc (articles)) %&gt;% plot.var (articles, sep.dim.names = country, type = &quot;point&quot;) + theme (axis.text.x = element_text (angle = 90, size = 6)) 3.3 Plotting multidimensional variables It is also possible to separate the data according to several dimensions (with not so many elements) at the same time in order to plot multidimensional variables. For example, the plot below gives the temporal evolution of articles for 8 countries and 2 newspapers. geomedia %&gt;% filter.elm (week, format (name, &quot;%Y&quot;) == &quot;2014&quot;) %&gt;% arrange.elm (week, name) %&gt;% top_n.elm (country, articles, 8) %&gt;% arrange.elm (country, desc (articles)) %&gt;% filter.elm (media, name %in% c (&quot;fr_FRA_lmonde_int&quot;, &quot;en_GBR_guardi_int&quot;)) %&gt;% plot.var (articles, sep.dim.names = list (country, media), type = &quot;point&quot;) + theme (axis.text.x = element_text (angle = 90, size = 6)) "],
["outlier-analysis.html", "4 Outlier Analysis 4.1 First example: Bidimensional outliers", " 4 Outlier Analysis One of the tools that the data.cube library offers deals with the detection of statistical outliers in multidimensional data. In this context, variables are interpreted as multidimensional contingency tables from which multiple marginal counts can be extracted (depending on the selected dimensions). These marginals then allow for the design of multiple models of the observed variables, from which significant deviations are then interpreted as outliers. In this part of the tutorial, we show how functions compute.var.model and plot.outliers allow for the computation of such models and the visualisation of the resulting deviations. For more details regarding the formal ground of these functions, please refer to: Audrey Wilmet and Robin Lamarche-Perrin. (2019). Multidimensional Outlier Detection in Temporal Interaction Networks. arXiv:1906.02541 4.1 First example: Bidimensional outliers This first example focuses on the evolution over year 2014 of the number of articles citing the 5 following countries: The United States, Russia, Spain, Italy, and Japan. geomedia_2014 &lt;- geomedia %&gt;% select.dim (week, country) %&gt;% filter.elm (week, format (name, &quot;%Y&quot;) == &quot;2014&quot;) %&gt;% arrange.elm (week, name) selected_countries &lt;- c (&quot;USA&quot;, &quot;RUS&quot;, &quot;ESP&quot;, &quot;ITA&quot;, &quot;JPN&quot;) geomedia_2014 %&gt;% filter.elm (country, name %in% selected_countries) %&gt;% plot.var (articles, sep.dim.names = country, type = &quot;line&quot;) + theme (axis.text.x = element_text (angle = 90, size = 6)) 4.1.1 Taking into account the expected number of articles for each country By plotting the distribution of all these observations, one could define some king of “statistically expected” range of values and then identify outliers as unexpectedly high (or unexpectedly low) values. In the plot below, one could for example grossly characterise the distribution as a Gaussian curve (values on the left) plus some positive outliers (values on the right). geomedia_2014 %&gt;% filter.elm (country, name %in% selected_countries) %&gt;% as.data.frame () %&gt;% ggplot (aes (x = articles)) + geom_histogram (aes (y = ..density..), binwidth = 30, colour = &quot;black&quot;, fill = &quot;white&quot;) + geom_density (alpha = 0.2, fill = &quot;black&quot;) Yet, it seems that several Gaussian distributions are actually superimposed. One could hence recognise that each of the five selected country has its own expected range of values, depending on its usual “media coverage” (expected number of articles per week). In this sense, one could hence search for outliers within each of these five distributions independently. geomedia_2014 %&gt;% filter.elm (country, name %in% selected_countries) %&gt;% as.data.frame () %&gt;% ggplot (aes (x = articles, color = country, fill = country)) + geom_histogram (aes (y = ..density..), binwidth = 30, alpha = 0.2, position = &quot;dodge&quot;) + geom_density (alpha = 0.2) To take into account these different ranges of values, another solution consists in normalising the observations by taking into account the expected “media coverage” of each country. Function compute.var.model aims at computing such normalisation models. This function take in argument a formula specifying the normalisation scheme that needs to be applied. In the example below, formula articles (week * country) ~ articles (country) indicates that we want to model variable articles associated to dimensions week and country (left-hand side) by taking into account its marginal total along dimension country (right-hand side). In other words, with this first model, the number of articles citing a given country during a given week is expected to be similar to the average number of articles citing that country each week (total number in the corpus divided by number of weeks). geomedia_2014 %&gt;% filter.elm (country, name %in% selected_countries) %&gt;% compute.var.model (articles (week * country) ~ articles (country)) %&gt;% summary () ## Computing model: articles (week * country) ~ articles (country) * NULL (week) ## data.cube of 2 dimensions and 3 variables ## ## -&gt; Dimension week ## - Element number: 52 ## - Class (type): Date (double) ## - Element names: 2014-05-19, 2014-10-13, 2014-06-09, 2014-05-26, 2014-06-16, ... ## ## -&gt; Dimension country ## - Element number: 5 ## - Class (type): character (character) ## - Element names: USA, ESP, JPN, RUS, ITA ## ## -&gt; Variable articles ## - Dimensions: week x country ## - Class (type): numeric (double) ## - NA value: num 0 ## ## -&gt; Variable articles.model ## - Dimensions: week x country ## - Class (type): numeric (double) ## - NA value: num NA ## ## -&gt; Variable articles.deviation ## - Dimensions: week x country ## - Class (type): numeric (double) ## - NA value: num 1 Applying the input formula, function compute.var.model computed two new variables: Variable articles.model is the aforementioned average number of articles for each country; Variable articles.deviation provides a measure of deviation between the observed variable article and the model. By default, it simply is the ratio between the two variables. For example, articles.deviation == 3 indicates that a given country has been three times more cited during a given week than usually. articles.deviation == 0.5 indicates that it has been two times less cited. These computed variables can now be visualised. Let’s first have a look at the model by plotting articles.model: It simply consists in the total number of articles, averaged among weeks, for each of the five countries. geomedia_2014 %&gt;% compute.var.model (articles (week * country) ~ articles (country)) %&gt;% filter.elm (country, name %in% selected_countries) %&gt;% plot.var (articles.model, sep.dim.names = country, type = &quot;line&quot;) + theme (axis.text.x = element_text (angle = 90, size = 6)) ## Computing model: articles (week * country) ~ articles (country) * NULL (week) ## Warning: Removed 1 rows containing missing values (geom_hline). We clearly see in the plot above that each of the five countries has a specific expected “media coverage” to which observations can be compared. To do so, we now plot variable articles.deviation that indicates the ratio between observed and expected values. geomedia_2014 %&gt;% compute.var.model (articles (week * country) ~ articles (country)) %&gt;% filter.elm (country, name %in% selected_countries) %&gt;% plot.var (articles.deviation, sep.dim.names = country, type = &quot;bar&quot;) + theme (axis.text.x = element_text (angle = 90, size = 6)) ## Computing model: articles (week * country) ~ articles (country) * NULL (week) This plot finally allows for the identification of outliers with respect to each country, relatively to its usual “media coverage”. Values are centered on 1, above are positive outliers, below are negative outliers. 4.1.2 Also taking into account the expected number of articles for each week geomedia_2014 %&gt;% select.dim (week) %&gt;% plot.var (articles, type = &quot;line&quot;) + theme (axis.text.x = element_text (angle = 90, size = 6)) geomedia_2014 %&gt;% compute.var.model (articles (week * country) ~ articles (week) * articles (country)) %&gt;% filter.elm (country, name %in% selected_countries) %&gt;% plot.var (articles.deviation, sep.dim.names = country, type = &quot;bar&quot;) + theme (axis.text.x = element_text (angle = 90, size = 6)) ## Computing model: articles (week * country) ~ articles (week) * articles (country) Note that function filter.elm is applied after function compute.var.model. "]
]
