[
["index.html", "A Tutorial for the data.cube Library Installation Authors and License", " A Tutorial for the data.cube Library data.cube is an R package for the exploration of multidimensional datasets and for the detection of statistical outliers within. It is mainly a tool for data exploration, allowing to have a first glance at it and to formulate research hypotheses to be later tested. The package defines a new data structure called data.cube that can be fed with a classical data.frame encoding a list of numeric observations described according to several categorical dimensions. For example, in the case of Twitter data, it can be the number of tweets (numeric observation) that have been published by a given user (first dimension) about a given topic (second dimension) at a given date (third dimension). The input data.frame hence takes the form of a list of quadruplets (user, topic, date, number of tweets). Statistical outliers can then be identified among the observations by first selecting some dimensions of interest, that is by subsetting or by aggregating the input dimensions. If needed, observations can also be normalised according to the marginal values along the selected dimensions, thus comparing the observed value to an expected value obtained by the uniform redistribution of the selected marginal values. Different statistical tests can then be chosen to measure the deviation between the observed and the expected values. The package finally allows to retrieve a list of positive outliers, that is observations that are significantly higher than expected. Installation The library is available on CRAN: install.packages (&#39;data.cube&#39;) Its source code is available on GitHub: https://github.com/Lamarche-Perrin/data.cube Authors and License This library has been developed by researchers of the Complex Networks team, within the Laboratoire d’informatique de Paris 6, for the ODYCCEUS project, founded by the European Commission FETPROACT 2016-2017 program under grant 732942. Copyright © 2017-2019 Robin Lamarche-Perrin (Robin.Lamarche-Perrin@lip6.fr) data.cube is free software: you can redistribute it and/or modify it under the terms of the GNU General Public License as published by the Free Software Foundation, either version 3 of the License, or (at your option) any later version. It is distributed in the hope that it will be useful, but WITHOUT ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the GN General Public License for more details. You should have received a copy of the GNU General Public License along with this program. If not, see http://www.gnu.org/licenses/. "],
["getting-started.html", "1 Getting Started 1.1 Downloading the dataset 1.2 Loading the library 1.3 Building the cube with as.data.cube 1.4 What’s in the cube with summary 1.5 Back to frame with as.data.frame", " 1 Getting Started This tutorial assumes that you are familiar with the most known R packages of the tidyverse, in particular tibble operations provided by dplyr and the forward-pipe operator %&gt;% provided by magrittr. 1.1 Downloading the dataset This tutorial presents a use case of the data.cube library on a quite simple dataset (downloadable here) referencing the citations of country names in press articles. This dataset has been extracted from the corpus of articles gathered by the ANR GEOMEDIA Project. First, import the main file of this dataset as a data.frame (actually, as a tibble): library (readr) df &lt;- read_csv (&#39;data/articles.csv&#39;) ## Parsed with column specification: ## cols( ## id_media = col_character(), ## week = col_date(format = &quot;&quot;), ## id_country = col_character(), ## article_nb = col_double() ## ) head (df) ## # A tibble: 6 x 4 ## id_media week id_country article_nb ## &lt;chr&gt; &lt;date&gt; &lt;chr&gt; &lt;dbl&gt; ## 1 en_NZL_nzhera_int 2015-06-01 SVK 0.333 ## 2 en_NZL_nzhera_int 2015-03-09 VEN 10.5 ## 3 es_VEN_univer_int 2014-05-19 LBY 9 ## 4 en_MYS_starmy_int 2014-10-13 PSE 9 ## 5 en_NZL_nzhera_int 2014-06-09 GTM 1.5 ## 6 en_MYS_starmy_int 2015-06-22 ARG 3 First column id_media contains standardised identifiers of selected newspapers. Second column week contains publication dates at the week level (date of the first day of the week at the YYYY-MM-DD format). Third column id_country contains standardised identifiers of cited countries (ISO 3166-1 alpha-3). Last column article_nb gives the corresponding number of articles, that is the number of articles published by id_media during week and citing id_country. For example, the third line of the dataset above indicates that the Venezuelan newspaper El Universal (es_VEN_univer_int) as published 9 articles talking about Libya (LBY) during the week starting on the 19th of May, 2014 (2014-05-19). Note that the indicated number of articles is not necessarily an integer value (see for example the first line) as an article simultaneously citing n countries is weighted by 1/n and then distributed among n lines. 1.2 Loading the library First, load the library: library (data.cube) 1.3 Building the cube with as.data.cube Function as.data.cube transforms a classical data.frame (or tibble) object into a data.cube, that is the data structure that will then be used by the library. One should specify which columns correspond to the cube’s dimensions (in our case, the first three) and which columns correspond to the observed variables (in our case, the last one). Note that one might also rename these dimensions and variables when transforming the data.frame into a data.cube. geomedia &lt;- df %&gt;% as.data.cube ( dim.names = list (media = id_media, week, country = id_country), var.names = list (articles = article_nb) ) ## Warning in as.data.cube_.data.frame(., str.dim.names, str.var.names): ## Observations are assumed to be unique. Check for potential duplicates in ## the input data.frame if unsure. 1.4 What’s in the cube with summary Function summary then prints a short summary of the data contained in the resulting structure. geomedia %&gt;% summary () ## data.cube of 3 dimensions and 1 variable ## ## -&gt; Dimension media ## - Element number: 36 ## - Class (type): character (character) ## - Element names: en_NZL_nzhera_int, es_VEN_univer_int, en_MYS_starmy_int, ... ## ## -&gt; Dimension week ## - Element number: 79 ## - Class (type): Date (double) ## - Element names: 2015-06-01, 2015-03-09, 2014-05-19, 2014-10-13, 2014-06-09, ... ## ## -&gt; Dimension country ## - Element number: 205 ## - Class (type): character (character) ## - Element names: SVK, VEN, LBY, PSE, GTM, ARG, ARM, AFG, NRU, MEX, IRN, ... ## ## -&gt; Variable articles ## - Dimensions: media x week x country ## - Class (type): numeric (double) ## - NA value: num 0 1.5 Back to frame with as.data.frame Function as.data.frame transforms a data.cube object back into a data.frame object (actually, a tibble). geomedia %&gt;% as.data.frame () ## # A tibble: 95,674 x 4 ## media week country articles ## &lt;chr&gt; &lt;date&gt; &lt;chr&gt; &lt;dbl&gt; ## 1 en_NZL_nzhera_int 2015-06-01 SVK 0.333 ## 2 en_NZL_nzhera_int 2015-03-09 VEN 10.5 ## 3 es_VEN_univer_int 2014-05-19 LBY 9 ## 4 en_MYS_starmy_int 2014-10-13 PSE 9 ## 5 en_NZL_nzhera_int 2014-06-09 GTM 1.5 ## 6 en_MYS_starmy_int 2015-06-22 ARG 3 ## 7 en_USA_wapost_int 2015-01-05 ARM 0.5 ## 8 es_VEN_univer_int 2014-05-26 AFG 4.5 ## 9 en_GBR_dailyt_int 2015-05-04 NRU 1 ## 10 fr_BEL_derheu_int 2014-06-16 MEX 0.333 ## # … with 95,664 more rows "],
["unidimensional-exploration.html", "2 Unidimensional Exploration 2.1 Selecting one dimension with select.dim 2.2 Arranging elements with arrange.elm 2.3 Plotting variables with plot.var 2.4 Filtering elements with filter.elm and top_n.elm 2.5 Other examples of use", " 2 Unidimensional Exploration In this first section, we focus on the exploration of one dimension of the data.cube. Multidimensional exploration is demonstrated later. 2.1 Selecting one dimension with select.dim One first needs to select the dimension of interest using function select.dim. In this example, we focus on the dataset’s temporal dimension, a.k.a. dimension week. geomedia %&gt;% select.dim (week) %&gt;% as.data.frame () ## # A tibble: 79 x 2 ## week articles ## &lt;date&gt; &lt;dbl&gt; ## 1 2015-06-01 5706. ## 2 2015-03-09 6316. ## 3 2014-05-19 5857. ## 4 2014-10-13 6006. ## 5 2014-06-09 5172. ## 6 2015-06-22 6738. ## 7 2015-01-05 5607. ## 8 2014-05-26 5260. ## 9 2015-05-04 6368. ## 10 2014-06-16 3384. ## # … with 69 more rows The resulting data.cube consists in a unidimensional data structure where variable articles has been aggregated (summed) along dimensions media and country. The resulting data.frame hence gives the total number of published articles corresponding to each element of dimension week. 2.2 Arranging elements with arrange.elm Note that above, observations have no particular order. Function arrange.elm reorders elements of a given dimension according to one (or several) of their variables. For example, the lexicographic order of their name (standard variable created for each dimension when instantiating the data.cube) which happens to also be the chronological order. geomedia %&gt;% select.dim (week) %&gt;% arrange.elm (week, name) %&gt;% as.data.frame () ## # A tibble: 79 x 2 ## week articles ## &lt;date&gt; &lt;dbl&gt; ## 1 2013-12-30 1671. ## 2 2014-01-06 2983. ## 3 2014-01-13 3172. ## 4 2014-01-20 3519. ## 5 2014-01-27 3073. ## 6 2014-02-03 2972. ## 7 2014-02-10 3012. ## 8 2014-02-17 2881. ## 9 2014-02-24 3313. ## 10 2014-03-03 3573. ## # … with 69 more rows 2.3 Plotting variables with plot.var Function plot.var then plots a variable. Note that it returns a ggplot object that can hence be modified using classical tools of the visualisation library. For example, one can use function theme to vertically display x-axis labels. geomedia %&gt;% select.dim (week) %&gt;% arrange.elm (week, name) %&gt;% plot.var (articles) + theme (axis.text.x = element_text (angle = 90, size = 6)) Several plot types are available: bar (above), line (below), and point. geomedia %&gt;% select.dim (week) %&gt;% arrange.elm (week, name) %&gt;% plot.var (articles, type = &quot;line&quot;) + theme (axis.text.x = element_text (angle = 90, size = 6)) 2.4 Filtering elements with filter.elm and top_n.elm Note that some observations in the plot above are surprisingly low. (They actually correspond to technical incidents during data collection.) Function top_n.elm only keeps the elements of a dimension that have the highest (or the lowest) value according to a variable. We here plot the 10 weeks in the data that have the lowest number of published article (note the - in argument n). geomedia %&gt;% select.dim (week) %&gt;% top_n.elm (week, articles, n = -10) %&gt;% arrange.elm (week, articles) %&gt;% plot.var (articles) + theme (axis.text.x = element_text (size = 6)) Function filter.elm only keeps the elements of a dimension that fit with some criteria expressed on variables. We can for example use it to remove such anomalous observations. geomedia %&gt;% select.dim (week) %&gt;% filter.elm (week, articles &gt;= 2500) %&gt;% arrange.elm (week, name) %&gt;% plot.var (articles, type = &quot;line&quot;) + theme (axis.text.x = element_text (angle = 90, size = 6)) 2.5 Other examples of use Here are other examples of use of these simple operations, illustrated on the spatial dimension country. One can plot the number of articles associated with the top 20 countries (arranged in a decreasing order). geomedia %&gt;% select.dim (country) %&gt;% top_n.elm (country, articles, 20) %&gt;% arrange.elm (country, desc (articles)) %&gt;% plot.var (articles) One can filter and arrange countries according to a given subset. G8 &lt;- c (&quot;USA&quot;, &quot;JPN&quot;, &quot;DEU&quot;, &quot;FRA&quot;, &quot;RUS&quot;, &quot;GBR&quot;, &quot;ITA&quot;, &quot;CAN&quot;) geomedia %&gt;% select.dim (country) %&gt;% filter.elm (country, name %in% G8) %&gt;% arrange.elm (country, match (name, G8)) %&gt;% plot.var (articles) "],
["multidimensional-exploration.html", "3 Multidimensional Exploration 3.1 Selecting two dimensions with select.dim 3.2 Plotting bidimensional variables with argument sep.dim.names of plot.var 3.3 Plotting multidimensional variables", " 3 Multidimensional Exploration In this second section, we simultaneously deal with several dimensions. Multidimensional plotting of variables is then possible. 3.1 Selecting two dimensions with select.dim When selecting two dimensions (or more) with function select.dim, one ends up with a multidimensional representation of the corresponding variables. For example, in the code below, one selects dimensions week and country (in other words, dimension media is aggregated). Each observation hence gives the number of articles published during a given week and talking about a given country. geomedia %&gt;% select.dim (week, country) %&gt;% arrange.elm (country, name) %&gt;% arrange.elm (week, name) %&gt;% as.data.frame () ## # A tibble: 11,051 x 3 ## week country articles ## &lt;date&gt; &lt;chr&gt; &lt;dbl&gt; ## 1 2013-12-30 AFG 22 ## 2 2013-12-30 ARG 6 ## 3 2013-12-30 AUS 29.5 ## 4 2013-12-30 BEN 2 ## 5 2013-12-30 BGD 30 ## 6 2013-12-30 BGR 7.67 ## 7 2013-12-30 BHS 2 ## 8 2013-12-30 BLR 0.5 ## 9 2013-12-30 BOL 2.5 ## 10 2013-12-30 BRA 10.5 ## # … with 11,041 more rows 3.2 Plotting bidimensional variables with argument sep.dim.names of plot.var In order to plot variable articles according to the two selected dimensions, one can use argument sep.dim.names of function plot.var to indicate which one of the two dimensions should be used to separate the data. geomedia %&gt;% select.dim (week, country) %&gt;% arrange.elm (week, name) %&gt;% filter.elm (country, name %in% c (&quot;USA&quot;, &quot;FRA&quot;, &quot;DEU&quot;)) %&gt;% plot.var (articles, sep.dim.names = country, type = &quot;line&quot;) + theme (axis.text.x = element_text (angle = 90, size = 6)) In this context, using a point-plot (instead of a line-plot) can be useful to separate a dimension with many elements. (Note that, below, we also use filter.elm on week to only plot data for year 2014.) geomedia %&gt;% select.dim (week, country) %&gt;% filter.elm (week, format (name, &quot;%Y&quot;) == &quot;2014&quot;) %&gt;% arrange.elm (week, name) %&gt;% top_n.elm (country, articles, 20) %&gt;% arrange.elm (country, desc (articles)) %&gt;% plot.var (articles, sep.dim.names = country, type = &quot;point&quot;) + theme (axis.text.x = element_text (angle = 90, size = 6)) 3.3 Plotting multidimensional variables It is also possible to separate the data according to several dimensions (with not so many elements) at the same time in order to plot multidimensional variables. For example, the plot below gives the temporal evolution of articles for 8 countries and 2 newspapers. geomedia %&gt;% filter.elm (week, format (name, &quot;%Y&quot;) == &quot;2014&quot;) %&gt;% arrange.elm (week, name) %&gt;% top_n.elm (country, articles, 8) %&gt;% arrange.elm (country, desc (articles)) %&gt;% filter.elm (media, name %in% c (&quot;fr_FRA_lmonde_int&quot;, &quot;en_GBR_guardi_int&quot;)) %&gt;% plot.var (articles, sep.dim.names = list (country, media), type = &quot;point&quot;) + theme (axis.text.x = element_text (angle = 90, size = 6)) "],
["outlier-analysis.html", "4 Outlier Analysis 4.1 First example: Bidimensional outliers 4.2 Plotting Outliers", " 4 Outlier Analysis One of the tools that the data.cube library offers deals with the detection of statistical outliers in multidimensional data. In this context, variables are interpreted as multidimensional contingency tables from which multiple marginal counts can be extracted (depending on the selected dimensions). These marginals then allow for the design of multiple models of the observed variables, from which significant deviations are then interpreted as outliers. In this part of the tutorial, we show how functions compute.var.model, compute.var.deviation, compute.var.outlier, and plot.var.outlier allow for the computation of such models and the visualisation of the resulting deviations. For more details regarding the formal ground of these functions, please refer to: Audrey Wilmet and Robin Lamarche-Perrin. (2019). Multidimensional Outlier Detection in Temporal Interaction Networks. arXiv:1906.02541 4.1 First example: Bidimensional outliers This first example focuses on the evolution over year 2014 of the number of articles citing the 5 following countries: The United States, Russia, China, Syria, and Japan. geomedia_2014 &lt;- geomedia %&gt;% select.dim (week, country) %&gt;% filter.elm (week, format (name, &quot;%Y&quot;) == &quot;2014&quot;) %&gt;% arrange.elm (week, name) selected_countries &lt;- c (&quot;USA&quot;, &quot;RUS&quot;, &quot;CHN&quot;, &quot;SYR&quot;, &quot;JPN&quot;) geomedia_2014 %&gt;% filter.elm (country, name %in% selected_countries) %&gt;% plot.var (articles, sep.dim.names = country, type = &quot;line&quot;) + theme (axis.text.x = element_text (angle = 90, size = 6)) 4.1.1 Taking into account the expected number of articles for each country By plotting the distribution of all these observations, one could define some king of “statistically expected” range of values and then identify outliers as unexpectedly high (or unexpectedly low) values. In the plot below, one could for example grossly characterise the distribution as a Gaussian curve (values on the left) plus some positive outliers (values on the right). geomedia_2014 %&gt;% filter.elm (country, name %in% selected_countries) %&gt;% as.data.frame () %&gt;% ggplot (aes (x = articles)) + geom_histogram (aes (y = ..density..), binwidth = 30, colour = &quot;black&quot;, fill = &quot;white&quot;) + geom_density (alpha = 0.2, fill = &quot;black&quot;) Yet, it seems that several Gaussian distributions are actually superimposed. One could hence recognise that each of the five selected country has its own expected range of values, depending on its usual “media coverage” (expected number of articles per week). In this sense, one could hence search for outliers within each of these five distributions independently. geomedia_2014 %&gt;% filter.elm (country, name %in% selected_countries) %&gt;% as.data.frame () %&gt;% ggplot (aes (x = articles, color = country, fill = country)) + geom_histogram (aes (y = ..density..), binwidth = 30, alpha = 0.2, position = &quot;dodge&quot;) + geom_density (alpha = 0.2) 4.1.1.1 Compute model with compute.var.model To take into account these different ranges of values, another solution consists in normalising the observations by taking into account the expected “media coverage” of each country. Function compute.var.model aims at computing such normalisation models. This function take in argument two formulas specifying the normalisation scheme that needs to be applied. In the example below, first formula articles (week * country) indicates that we want to model variable articles associated to dimensions week and country and second formula articles (country) indicates that the model in question should take into account the marginal total of this variable along dimension country. In other words, with this first model, the number of articles citing a given country during a given week is expected to be similar to the average number of articles citing that country each week, that is the total number of articles citing that country divided by the number of weeks. Formally, given \\(w \\in \\texttt{week}\\) and \\(c \\in \\texttt{country}\\), we have \\[\\texttt{articles.model}(w,c) \\quad = \\quad \\frac{\\texttt{articles}(.,c)}{|\\texttt{week}|} \\text{,}\\] where \\(\\texttt{articles}(.,c)\\) denotes the marginal total along dimension country: \\[\\texttt{articles}(.,c) \\quad = \\quad \\sum_{w&#39; \\in \\texttt{week}} {\\texttt{articles}(w&#39;,c)} \\text{.}\\] geomedia_2014 %&gt;% filter.elm (country, name %in% selected_countries) %&gt;% compute.var.model (articles (week * country), articles (country)) %&gt;% summary () ## Computing model &#39;articles (week * country) ~ articles (country) * NULL (week)&#39; ## data.cube of 2 dimensions and 2 variables ## ## -&gt; Dimension week ## - Element number: 52 ## - Class (type): Date (double) ## - Element names: 2014-05-19, 2014-10-13, 2014-06-09, 2014-05-26, 2014-06-16, ... ## ## -&gt; Dimension country ## - Element number: 5 ## - Class (type): character (character) ## - Element names: USA, CHN, JPN, SYR, RUS ## ## -&gt; Variable articles ## - Dimensions: week x country ## - Class (type): numeric (double) ## - NA value: num 0 ## ## -&gt; Variable articles.model ## - Dimensions: week x country ## - Class (type): numeric (double) ## - NA value: num 0 We see that compute.var.model computed a new variable that has been added to the data.cube: Variable articles.model, that is the average number of articles per week for each country (see above). Let’s now visualise it with plot.var. geomedia_2014 %&gt;% compute.var.model (articles (week * country), articles (country)) %&gt;% filter.elm (country, name %in% selected_countries) %&gt;% plot.var (articles.model, sep.dim.names = country, type = &quot;line&quot;) + theme (axis.text.x = element_text (angle = 90, size = 6)) ## Computing model &#39;articles (week * country) ~ articles (country) * NULL (week)&#39; This plot simply consists in the average number of articles per week for each of the five countries. We clearly see here that they all have a different expected value to which observations can then be compared. 4.1.1.2 Compute deviation with compute.var.deviation Function compute.var.deviation provides a measure of deviation between the observed variable article and the computed variable articles.model. It hence compute a third variable articles.deviation which is, by default, the ratio between the two variables, that is the ratio between observed and expected values (see below for other deviation measures). geomedia_2014 %&gt;% compute.var.model (articles (week * country), articles (country)) %&gt;% compute.var.deviation (articles (week * country)) %&gt;% filter.elm (country, name %in% selected_countries) %&gt;% plot.var (articles.deviation, sep.dim.names = country, type = &quot;bar&quot;) + theme (axis.text.x = element_text (angle = 90, size = 6)) ## Computing model &#39;articles (week * country) ~ articles (country) * NULL (week)&#39; ## Computing deviation of &#39;articles (week * country)&#39; Hence, in the plot above, articles.deviation == 3 indicates that a country has been three times more cited during a week than usually, and articles.deviation == 0.5 indicates that it has been two times less cited. This plot finally allows for the identification of outliers for each country through time, relatively to their usual “media coverage”. Values are centered on 1. Above this line are positive outliers (more cited than usual) and below are negative outliers (less cited than usual). 4.1.2 Also taking into account the expected number of articles for each week We just saw that the average number of articles is not comparable from one country to another. Similarly, one could point out that the total number of articles is not constant over time. geomedia_2014 %&gt;% select.dim (week) %&gt;% plot.var (articles, type = &quot;line&quot;) + theme (axis.text.x = element_text (angle = 90, size = 6)) In particular, as we see in the plot above, the dataset we explore contains much less articles during the first weeks of 2014 than later during the year. (This is due to data collection issues.) As a result, it is less likely to observe outliers during that period from the simple fact that observations are almost always below the computed averages. Conversely, outliers that are identified at the end of the year are slightly overestimated as global activity is higher than average at that time. To compensate for these temporal variations, one can also include them in the computed model. In the plot below, model formula articles (country) * articles (week) indicates that marginal totals are taken into account both for dimension country (as above) and for dimension week. The number of articles citing a given country during a given week is hence expected to be similar to the total number of articles citing that country multiplied by the total number of articles published during that week divided by the total number of articles in the corpus. Formally, given \\(w \\in \\texttt{week}\\) and \\(c \\in \\texttt{country}\\), we have \\[\\texttt{articles.model}(w,c) \\quad = \\quad \\frac{\\texttt{articles}(.,c) \\; \\texttt{articles}(w,.)}{\\texttt{articles}(w,c)} \\text{,}\\] where \\(\\texttt{articles}(w,.)\\) denotes the marginal total along dimension week and \\(\\texttt{articles}(.,.)\\) denotes the grand total. It results a normalisation model that both takes into account the average “media coverage” of each country and the global temporal variations. First, the model: geomedia_2014 %&gt;% compute.var.model (articles (week * country), articles (week) * articles (country)) %&gt;% filter.elm (country, name %in% selected_countries) %&gt;% plot.var (articles.model, sep.dim.names = country, type = &quot;line&quot;) + theme (axis.text.x = element_text (angle = 90, size = 6)) ## Computing model &#39;articles (week * country) ~ articles (week) * articles (country)&#39; Second, the deviation: geomedia_2014 %&gt;% compute.var.model (articles (week * country), articles (week) * articles (country)) %&gt;% compute.var.deviation (articles (week * country)) %&gt;% filter.elm (country, name %in% selected_countries) %&gt;% plot.var (articles.deviation, sep.dim.names = country, type = &quot;bar&quot;) + theme (axis.text.x = element_text (angle = 90, size = 6)) ## Computing model &#39;articles (week * country) ~ articles (week) * articles (country)&#39; ## Computing deviation of &#39;articles (week * country)&#39; Contrary to the previous deviation plot, we can see here some outliers appearing during the first weeks of 2014, even though the global “media activity” on that period is lower than during the rest of the year. Warning! Note that, in the operation sequence above, function compute.var.model (computing the model) is called before function filter.elm (selecting the five countries of interest). Order is important! The normalisation model (and in particular the global “media activity”) is here computed with respect to the full corpus, and not only with respect to the subset of countries. Filtering of elements is here applied after computing the model just to reduce the number of curves to be displayed in the plot. 4.1.3 Significativity of deviations Ratio between observed and expected values induce interpretation errors has it does not account for the statistical significativity of deviations. Indeed, with this basic measure, observing 2 articles when expecting 1 is considered as surprising as observing 200 when expecting 100. Yet, variations on small numbers can be the result of noisy data or randomness in the observed processes. Function compute.var.deviation hence proposes several measures to account for the significativity of deviations. To this end, argument deviation.type can take the following values: ratio \\[\\texttt{var.deviation} \\quad = \\quad \\frac{\\texttt{var}}{\\texttt{var.model}}\\] chi2 \\[\\texttt{var.deviation} \\quad = \\quad \\left\\{ \\begin{array}{l} \\hphantom{-} \\displaystyle\\frac{(\\texttt{var} - \\texttt{var.model})^2}{\\texttt{var.model}}\\\\ \\hspace{1em} \\text{if } \\texttt{var} \\geq \\texttt{var.model}\\\\[1ex] - \\displaystyle\\frac{(\\texttt{var} - \\texttt{var.model})^2}{\\texttt{var.model}}\\\\ \\hspace{1em} \\text{if } \\texttt{var} \\leq \\texttt{var.model} \\end{array}\\right.\\] poisson \\[\\texttt{var.deviation} \\quad = \\quad \\left\\{ \\begin{array}{l} \\hphantom{-} \\log\\Pr (\\texttt{var} \\geq \\text{Pois}(\\texttt{var.model}))\\\\ \\hspace{3em} \\text{if } \\texttt{var} \\geq \\texttt{var.model}\\\\[1ex] - \\log\\Pr (\\texttt{var} \\leq \\text{Pois}(\\texttt{var.model}))\\\\ \\hspace{3em} \\text{if } \\texttt{var} \\leq \\texttt{var.model} \\end{array}\\right.\\] KLdiv \\[\\texttt{var.deviation} \\quad = \\quad \\frac{\\texttt{var}}{\\sum{\\texttt{var}}} \\; \\log_2 \\left (\\frac{\\texttt{var}}{\\texttt{var.model}} \\right)\\] 4.2 Plotting Outliers "]
]
